; arcadeEIP (eip.exe) - Arcade Emulator Integration Player
; Â© 2023 David G. Dahlstrom
; File: eipFunctions.ahk2

;Miscellaneous support functions

;Vector to another emulator/game. This function prepares A_Args to vector to a new game. After
;calling this function, the caller will normally execute a Goto Vector: in the main thread.
;Note 1: The vector passed in should not include extra arguments (just a vector)
;Note 2: These "extra arguments" (such as passthrough arguments like -video gdi) passed in the original
; commandline should contine to work assuming they are compatible with the emulator being vectored to 
; since the vectored emulator provides support for these passthrough args in its param_list).
VectorNow(vector)
{
    global A_Args

    emu := SplitVector(vector)["sys_key"]
    romspec := SplitVector(vector)["rom_value"]

    ;Fill in possible template fields (for example, in support of the vector_to rule)
    ;------------------------------------------------------------------------------------------------------
    romspec := InsertTemplateField(romspec, "[sys_key]", gCfg.sys_key, "romspec")
    romspec := InsertTemplateField(romspec, "[asset_name]", gCfg.asset_name, "romspec")
    romspec := InsertTemplateField(romspec, "[root_folder]", gCfg.root_folder, "romspec")
    romspec := InsertTemplateField(romspec, "[rom_full_path]", gCfg.rom_full_path, "romspec")
    romspec := InsertTemplateField(romspec, "[rom_file]", gCfg.rom_file, "romspec")
    romspec := InsertTemplateField(romspec, "[rom_folder]", gCfg.rom_folder, "romspec")
    romspec := InsertTemplateField(romspec, "[rom_folder_parent]", gCfg.rom_folder_parent, "romspec")
    romspec := InsertTemplateField(romspec, "[rom_name]", gCfg.rom_name, "romspec")	
    ;If [rom] is specified, use either rom_name or rom_full_path depending on which is available
    if (gCfg.rom_full_path)
        romspec := InsertTemplateField(romspec, "[rom]", gCfg.rom_full_path, "romspec")
    else if (gCfg.rom_file)
        romspec := InsertTemplateField(romspec, "[rom]", gCfg.rom_file, "romspec")
    else
        romspec := InsertTemplateField(romspec, "[rom]", gCfg.rom_name, "romspec")
    ;------------------------------------------------------------------------------------------------------
    
    A_Args := Array()

    if (oEmulators.IsValidKey(emu))
    {
        A_Args.Push(emu)
        A_Args.Push(romspec)
    }
    else
    {
        A_Args.Push(romspec)
    }

    return
}

GetSysKeyFromCmdLine(args)
{
    ;if no parameters, return the default emulator's sys_key
    if (args.Length == 0)
        return oEmulators.GetDefaultSysKey()
    
    ;if first parameter is a valid sys_key, return it
    if (oEmulators.IsValidKey(args[1])) 
        return args[1]
    
    ;otherwise assume first param must be a rom and return default emulator key
    return oEmulators.GetDefaultSysKey()
}

;Replace passthrough <...> items in a param list with values from command line
;oArgs should be the original command line array
;sParamList should be the param_list string
;oArgs is returned with the passthrough values removed
;sParamList is returned with the passthrough templates replaced
ProcessPassthroughArgs(&oArgs, sParamList)
{
    oParamList := Array()
    
    Loop Parse sParamList, A_Space, A_Space
        oParamList.Push(A_LoopField)
    
    sParamList := ""
    for n, param_arg in oParamList
    {
        if (SubStr(param_arg, 1, 1) == "<" && SubStr(param_arg, StrLen(param_arg), 1) == ">")
        {
            oParam := StrSplit(param_arg, ["=", ","], "<>")
            for p, originalArg in oArgs
            {
                if (originalArg == oParam[1])
                {
                    sParamList := sParamList " " oArgs[p]
                    oArgs[p] := ""
                    nArgs := oParam[2]
                    loop nArgs
                    {
                        sParamList := sParamList " " oArgs[p + A_Index]
                        oArgs[p + A_Index] := ""
                    }
                }
            }
        }
        else
        {
            sParamList := Trim(sParamList . " " . param_arg)
        }
    }
    ReindexArray(&oArgs)
    
    return sParamList
}

;This function uses the folder information defined in the configuration along with the rom name
;to obtain a fully qualified path to a specific asset file.
;assetTypes are "logo", "marquee", and "controls" (i.e. control panel layouts)
SetAssetFullPath(assetType, romName, assetFolder, systemAsset, globalAssetName)
{
    ;Look in the asset folder for a png or jpg based on the rom file name.
    if (romName && assetFolder)
    {
        assetFullPath := assetFolder "\" romName ".png"
        assetFullPath := GetRegionalAsset(assetFullPath) ;mainly for LaunchBox/BigBox support
        if (FileExist(assetFullPath))
            return assetFullPath
        
        assetFullPath := assetFolder "\" romName ".jpg"
        assetFullPath := GetRegionalAsset(assetFullPath)
        if (FileExist(assetFullPath))
            return assetFullPath
    }

    ;Fallback 1: If a Marquee, use the rom's Clear Logo
    if (assetType == "marquee") ;check if a BigBox resource is available
    {
        assetFullPath := gCfg.logo_folder "\" romName ".png"
        assetFullPath := GetRegionalAsset(assetFullPath) ;mainly for LaunchBox/BigBox support
        if (FileExist(assetFullPath))
            return assetFullPath
        
        assetFullPath := gCfg.logo_folder "\" romName ".jpg"
        assetFullPath := GetRegionalAsset(assetFullPath)
        if (FileExist(assetFullPath))
            return assetFullPath
    }

    ;Fallback 2: Look in the asset folder for a png or jpg based on the asset type.
    if (assetFolder && globalAssetName)
    {
        assetFullPath := assetFolder "\" globalAssetName ".png"
        if (FileExist(assetFullPath))
            return assetFullPath
        
        assetFullPath := assetFolder "\" globalAssetName ".jpg"
        if (FileExist(assetFullPath))
            return assetFullPath
    }

    ;Fallback 3: Look in the system folder for a png or jpg based on the asset type.
    if (systemAsset)
    {
        if (FileExist(systemAsset))
            return systemAsset
    }    

    ;Fallback 4: If a Marquee, use the system's clear logo
    if (assetType == "marquee" && gCfg.system_logo)
    {
        if (FileExist(gCfg.system_logo))
            return gCfg.system_logo
    }

    ;Fallback 5: Use the arcadeEIP default
    assetFullPath := ".\Assets\Default\" assetType "\default.png"
    if (FileExist(assetFullPath))
        return assetFullPath
    
    assetFullPath := ""
    
    return assetFullPath
}

;Checks if regional asset file, such as a logo, exists.
;Returns the path to the region prioritized.
;Mainly here for LaunchBox/BigBox support
GetRegionalAsset(assetPath, sysKey:="")
{
    if (!assetPath)
        return

    asset := ""

    ;Requests from the menu will provide the sysKey, while current game requests can use the global.
    if (sysKey == "")
        sysKey := gCfg.sys_key

    SplitPath assetPath, &OutFileName, &OutDir, &OutExtension, &OutNameNoExt, &OutDrive

    ;Get the meta file name
    gameTitle := oEmulators.Emulators[sysKey].meta_names.GetTitle(OutNameNoExt)

    ;Replace illegal filename characters
    gameTitle := StrReplace(gameTitle, ":", "_") ;Launchbox replaces : with underscores in filenames
    gameTitle := StrReplace(gameTitle, "/", "_") ;Launchbox replaces / with underscores in filenames
    gameTitle := StrReplace(gameTitle, "'", "_") ;Launchbox replaces ' with underscores in filenames

    ;Get the BigBox/LaunchBox id, just in case.
    gameID := oEmulators.Emulators[sysKey].meta_names.GetTitle(OutNameNoExt, "id")

    ;get ordered list of priority region folders
    oRegionPriorities := oLaunchBox.GetRegionPriorities(OutDir)

    ;Look in each of the prioritized region folders first
    for n, folder in oRegionPriorities
    {
        ;Check for the native name (i.e. named after the rom)
        thisPath := OutDir "\" folder "\" OutFileName
        Loop Files thisPath
            return A_LoopFileFullPath

        ;Check for the LaunchBox/BigBox mangled form of the file name
        thisPath := OutDir "\" folder "\" OutNameNoExt "-??." OutExtension
        Loop Files thisPath
            return A_LoopFileFullPath
    
        if (gameTitle)
        {
            thisPath := OutDir "\" folder "\" gameTitle "-??." OutExtension
            Loop Files thisPath
                return A_LoopFileFullPath

            if (gameID)
            {
                thisPath := OutDir "\" folder "\*." gameID "-??." OutExtension
                Loop Files thisPath
                    return A_LoopFileFullPath
            }

            ;Also try with parenthetical text removed
            if (InStr(gameTitle, "("))
            {
                gameTitleNoParens := Trim(SubStr(gameTitle, 1, InStr(gameTitle, "(") - 1))
                thisPath := OutDir "\" folder "\" gameTitleNoParens "-??." OutExtension
                Loop Files thisPath
                    return A_LoopFileFullPath            
            }
        }
    }

    ;Now check in the root folder (and all subfolders) for the LaunchBox/BigBox mangled form of the filename
    ;We recurse all subfolders here (R option) in case the file is in one of the regional folders that 
    ;we didn't already check above.
    thisPath := OutDir "\" OutNameNoExt "-??." OutExtension
    Loop Files thisPath, "R"
        return A_LoopFileFullPath

    if (gameTitle)
    {
        thisPath := OutDir "\" gameTitle "-??." OutExtension
        Loop Files thisPath, "R"
            return A_LoopFileFullPath

        if (gameID)
        {
            thisPath := OutDir "\*." gameID "-??." OutExtension
            Loop Files thisPath, "R"
                return A_LoopFileFullPath
        }

        ;Also try root folder with parenthetical text removed
        if (InStr(gameTitle, "("))
        {
            gameTitle := Trim(SubStr(gameTitle, 1, InStr(gameTitle, "(") - 1))
            thisPath := OutDir "\" gameTitle "-??." OutExtension
            Loop Files thisPath, "R"
                return A_LoopFileFullPath
        }
    }

    ;Finally check in the root folder for the native name (i.e. named after rom)
    Loop Files assetPath, "R"
        return A_LoopFileFullPath

    return asset
}

;Parse a decorated command line and return the base command line along 
;with any specified runtime options.
ParseRTParams(cl, &runStyle, &runOption, &windowStyle, &winset_style)
{
    ;Split the exe path and retun along with any options specified.

    runStyle := runOption := windowStyle := winset_style := "" ;init

    ;Four options supported
    ; runStyle = "RunWait" (default) or "Run" (if "nowait" specified on cl)
    ; runOption = "" (default) or "Min" (if "min" specified on cl)
    ; windowStyle = "" (default) or "NoHide" (if "nohide" specified on cl)
    ; noTitle = false (default) or true (if "notitle" specified on cl)

    if (runStyle == "")
        runStyle := "RunWait"

    ;Get path and options
    if (InStr(cl, gCfg.path_delimiter))
    {
        cl_path := Trim(SubStr(cl, 1, InStr(cl, gCfg.path_delimiter,,1,1)-1))
        cl_options := SubStr(cl, StrLen(cl_path)+1)
    }
    else
    {
        cl_path := cl    
        cl_options := ""   
    }

    if (InStr(cl_options, "nowait"))
        runStyle := "Run"

    if (InStr(cl_options, "min"))
        runOption := "Min"

    if (InStr(cl_options, "nohide"))
        windowStyle := "NoHide" ;Window gets hidden by bookend screens

    if (InStr(cl_options, "winset"))
        winset_style := "winset"
    if (InStr(cl_options, "winset_A"))
        winset_style := "winset_A"
    if (InStr(cl_options, "winset_B"))
        winset_style := "winset_B"
    if (InStr(cl_options, "winset_C"))
        winset_style := "winset_C"
    if (InStr(cl_options, "winset_D"))
        winset_style := "winset_D"

    return cl_path
}

;build aEmuArgs parameter array from param_list string
BuildEmuArgs() 
{
    global aEmuArgs

    idx := 1
    startString := false ;used in processing double-quoted items having spaces
    aEmuArgs := Array()

    Loop Parse gCfg.param_list, A_Space, A_Space
    {	
        ;if (SubStr(A_LoopField, 1, 1) = """")
        ;This revised test allows the first quote to be embedded in the string in support of arguments like:
        ;  -"This parameter starts with a dash"
        ;Visual pinball uses this sort of parameter.
        ;We test to see if a " is in the string, but does not end with a "
        
        if (InStr(A_LoopField, "`"") && SubStr(A_LoopField, StrLen(A_LoopField), 1) != "`"")
        { 
            aEmuArgs.Push(A_LoopField)
            
            if (SubStr(A_LoopField, StrLen(A_LoopField), 1) = "`"")
            {
                startString := false
                idx := idx + 1
            }
            else
                startString := true
            
            continue
        }
        
        else if (SubStr(A_LoopField, StrLen(A_LoopField), 1) = "`"")
        {
            if (!aEmuArgs.Has(idx))
                aEmuArgs.Push(A_LoopField)
            else
                aEmuArgs[idx] := aEmuArgs[idx] . " " . A_LoopField
            
            startString := false
            idx := idx + 1
            continue
        }
        
        else if (startString)
            aEmuArgs[idx] := aEmuArgs[idx] . " " . A_LoopField
        
        else
        {
            aEmuArgs.Push(A_LoopField)
            idx := idx + 1
        }		
    }
}

; Rebuild param_list from aEmuArgs
BuildParamList()
{    
    global gCfg

    gCfg.param_list := ""
    for n, param in aEmuArgs ; For each parameter:
        gCfg.param_list := gCfg.param_list " " param
}

;Fill in templates in the parameter list such as [sys_key], [root_folder], etc.
ProcessParamListTemplates()
{
    global gCfg

    ;refresh _settings with any changes made to local variables
    for z, emu_set in oEmulators.Emulators[gCfg.sys_key]._settings
        oEmulators.Emulators[gCfg.sys_key]._settings[z] := gCfg.%z%

    ;update all templates
    oEmulators.Emulators[gCfg.sys_key].UpdateSystem()

    ;now refresh all the local variables with templates filled
    for z, emu_set in oEmulators.Emulators[gCfg.sys_key]._settings
        gCfg.%z% := emu_set
    
    ;if a search_path was defined in arcadeEIP.ini, and there was no rom_folder specified on the 
    ;command line, then add the rom_folder so that we can support the [rom_full_path], 
    ;[rom_folder], and [rom] template items even if only given a rom_file on the command line.
    if (gCfg.search_path != "" && gCfg.rom_folder = "" && gCfg.rom_file != "")
    {
        if (!GetRoms(gCfg.sys_key, gCfg.rom_file, &romList))
        {
            LogEntry("====================================================================================================`n")

            ;if the rom can't be found, then for error reporting purposes, first check to see if the path to the emulator
            ;is valid, since that could be the underlying cause, and more useful to report.
            cl := ParseRTParams(gCfg.exe_full_path, &runStyle, &runOption, &windowStyle, &winset_style) 
            if (!FileExist(cl))
            {
                LogEntry("NOTICE: An emulator at the location: " cl " could not be found.`n")
                LogEntry("NOTICE: Please review the configuration file (" cConfigFileName "), and ensure that the value`n" )
                LogEntry("NOTICE: of exe_full_path in the section having sys_key=" gCfg.sys_key ", points to a valid folder and filename.`n")
                LogEntry("ERROR: Could not continue.`n")
            }
            else
            {
                LogEntry("NOTICE: Rom file [" gCfg.rom_file "] could not be found in the search path.`n")
                LogEntry("NOTICE: Please ensure that the file exists, and if so, review the configuration file (" cConfigFileName "),`n" )
                LogEntry("NOTICE: and ensure that the search_path in the section having sys_key=" gCfg.sys_key " is valid.`n")
                LogEntry("ERROR: Could not continue.`n")
            }
            ExitApp
        }
        else
        { ;the default "best" rom found is always returned in romList[1]
            if (romList[1].system != gCfg.sys_key)
            {
                OutputDebug "assert_goto_scenario"
				LogEntry("ASSERT GOTO SCENARIO: Investigate this case.`n")
				ExitApp

                LogEntry("INFO: Vectoring to: " . romList[1].system . " " . romList[1].fullPath . " from within ProcessParamListTemplates.`n")
                VectorNow(romList[1].system . " " . romList[1].fullPath)
            
                return
            }
            else
            {
                gCfg.rom_full_path := romList[1].fullPath
                gCfg.rom_file := romList[1].fileName
                gCfg.rom_folder := romList[1].folder
                gCfg.rom_ext := romList[1].extension
                gCfg.rom_name := romList[1].name
            }
        }
    }
    
    ;rom_folder_parent := SubStr(gCfg.rom_folder, 1, InStr(gCfg.rom_folder, "\",,0,1)-1)
    gCfg.rom_folder_parent := SubStr(gCfg.rom_folder, 1, InStr(gCfg.rom_folder, "\",,,-1)-1)
    
    ;param_list supports 
    ;[sys_key] [asset_name] [root_folder] [rom] [rom_full_path], [rom_file], [rom_folder], [rom_name], [param_list]
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[sys_key]", gCfg.sys_key, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[asset_name]", gCfg.asset_name, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[root_folder]", gCfg.root_folder, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom_full_path]", gCfg.rom_full_path, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom_file]", gCfg.rom_file, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom_folder]", gCfg.rom_folder, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom_folder_parent]", gCfg.rom_folder_parent, "param_list")
    gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom_name]", gCfg.rom_name, "param_list")
    
    ;If [rom] is specified, use either rom_name or rom_full_path depending
    ;on which is available
    if (gCfg.rom_full_path)
        gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom]", gCfg.rom_full_path, "param_list")
    else if (gCfg.rom_file)
        gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom]", gCfg.rom_file, "param_list")
    else
        gCfg.param_list := InsertTemplateField(gCfg.param_list, "[rom]", gCfg.rom_name, "param_list")
    
    if (gCfg.root_folder)
        gCfg.exe_full_path := gCfg.root_folder "\" gCfg.exe_name
    else
        gCfg.exe_full_path := gCfg.exe_name
    
    ;exe_full_path supports
    ;[sys_key] [asset_name] [rom] [rom_full_path], [rom_file], [rom_folder], [rom_name]
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[sys_key]", gCfg.sys_key, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[asset_name]", gCfg.asset_name, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom_full_path]", gCfg.rom_full_path, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom_file]", gCfg.rom_file, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom_folder]", gCfg.rom_folder, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom_folder_parent]", gCfg.rom_folder_parent, "exe_full_path")
    gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom_name]", gCfg.rom_name, "exe_full_path")	
    
    ;If [rom] is specified, use either rom_name or rom_full_path depending
    ;on which is available
    if (gCfg.rom_full_path)
        gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom]", gCfg.rom_full_path, "exe_full_path")
    else if (gCfg.rom_file)
        gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom]", gCfg.rom_file, "exe_full_path")
    else
        gCfg.exe_full_path := InsertTemplateField(gCfg.exe_full_path, "[rom]", gCfg.rom_name, "exe_full_path")
    
    rfolder := gCfg.root_folder
    SplitPath(gCfg.exe_full_path,,&rfolder) ;make sure root_folder is updated
    gCfg.root_folder := rfolder
}

;This function obtains rom file path(s) from the vector components
;syskey and romname. For example, passing in "mame" to this function as the sysKey
;and "gala" as the romFileName will return an object (oRoms) containing the paths
;to all potential matches, with the best match returned in the first record. This function
;relies on the search paths existing in the system's configuration, and is useful
;when an absolute path was not supplied on the command line.
GetRoms(sysKey, romFileName, &oRoms)
{
    bFoundRom := false
    originalRom := romFileName

    ;oRoms is an array of rom_class objects.  
    ;oRoms[1] will hold the "best" found rom (with null values if none found)
    ;The remaining rom_class objects will hold all the found roms (including the "best")
    oRoms := Array()
    oRoms.Push(rom_class("","","")) ;init "best" rom to all null values
    
    if (bSearchGlobal)
    {		
        for n, emulator in oEmulators.Emulators
            GetFuzzyRom(emulator.sys_key, romFileName, &oRoms)
    }
    else	
        GetFuzzyRom(sysKey, romFileName, &oRoms)
    
    ;Now set the oRoms[1] to the best rom found
    for n, romObj in oRoms
    {
        if (romObj.matchType == "exactMatch")
        {
            oRoms[1].matchType := romObj.matchType
            oRoms[1].system := romObj.system
            oRoms[1].fullPath := romObj.fullPath
            return true
        }
        if (romObj.matchType == "strongMatch" && oRoms[1].matchType != "strongMatch")
        {
            oRoms[1].matchType := romObj.matchType
            oRoms[1].system := romObj.system
            oRoms[1].fullPath := romObj.fullPath
            bFoundRom := true
        }
        if (romObj.matchType == "weakMatch" && oRoms[1].matchType = "")
        {
            oRoms[1].matchType := romObj.matchType
            oRoms[1].system := romObj.system
            oRoms[1].fullPath := romObj.fullPath
            bFoundRom := true
        }			
    }
    
    LogEntry("INFO: Rom [" originalRom "] not found. Using first closest file match [" oRoms[1].fileName "]`n")	
    
    return bFoundRom		
}

;finds the first rom having a specified substring
;Only supported if a search_path was defined since we need the wildcard
;If using with the <change_root> rule, must keep in mind that if there
;is a search miss in the searchPath, the root search will fail.

;search may include a comma-delimited list of extensions
;For example: C:\mypath\myroms\*.rom,bin,iso
GetFuzzyRom(sysKey, romFileName, &oRoms)
{ 
    try 
    {
        aSearchPaths := ParseSearchPath(sysKey)
        if (!aSearchPaths)
            return false
    } 
    catch as e
    {			

        LogEntry("ERROR: SEARCH PATH: " . FormatErrorMessage(e) . "`n")
        ExitApp
    }
    
    SplitPath romFileName,,,,&romName
    for n, searchPath in aSearchPaths
    {
        SplitPath searchPath,,&searchFolder, &searchExt, &searchRomName
        romExtensions := StrSplit(searchExt, gCfg.path_delimiter, " ")
        
        for n, romExt in romExtensions
        {
            currentSearchFolder := searchFolder . "\" . searchRomName . "." . romExt
            Loop Files currentSearchFolder
            {
                strongMatch := false
                weakMatch := false

                if (!gCfg.fast_load)
                    rom_title := oEmulators.Emulators[sysKey].meta_names.GetTitle(A_LoopFileName)                  
                if (A_LoopFileName == romFileName || rom_title == romFileName)
                    oRoms.Push(rom_class(sysKey,A_LoopFileFullPath,"exactMatch"))
                else
                {
                    if (InStr(A_LoopFileName, romFileName, false))
                    {
                        SplitPath A_LoopFileName,,,,&foundName
                        if (romName = foundName) ;use of = here is case insensitive, whereas == is case sensitive
                            strongMatch := true
                        else
                            weakMatch := true
                    }
                    if (InStr(rom_title, romFileName, false))
                    {
                        if (rom_title == romFileName)
                            strongMatch := true
                        else
                            weakMatch := true
                    }

                    if (strongMatch)
                        oRoms.Push(rom_class(sysKey, A_LoopFileFullPath, "strongMatch"))
                    else if (weakMatch)
                        oRoms.Push(rom_class(sysKey, A_LoopFileFullPath, "weakMatch"))
                }
            }
        }
    }
    
    return true
}

ProcessEmulatorSettings(config_section)
{
    global mRules
    
    ProcessEmulatorOverrides()
    
    ProcessParamListTemplates()
    
    ;Create and fill-in the mRules structure
    ;rule = [function] arg_1 [policy] arg_2
    mRules := Map()
    Loop 
    {
        config_item := "rule_" . A_Index
  
        try {
            rule := IniRead(config_file, config_section, config_item)
        }
        catch as e {
            break
        }
        
        mRules[A_Index] := {}
        idx := A_Index

        Loop Parse rule, "<>", A_Space  
        {
            if (A_Index == 2) 
                mRules[idx].function := A_LoopField	
            
            else if (A_Index == 3)
            {
                mRules[idx].arg_1 := A_LoopField
                
                ;<change_root> rule supports [root_folder] in arg_1
                if mRules[idx].function = "change_root"
                    mRules[idx].arg_1 := StrReplace(A_LoopField, "[root_folder]", gCfg.root_folder)
            }
            
            else if (A_Index == 4)
                mRules[idx].policy := A_LoopField
            
            else if (A_Index == 5)
                mRules[idx].arg_2 := A_LoopField
            
            else if (A_Index == 6)
                mRules[idx].case_1 := A_LoopField
            
            else if (A_Index == 7)
                mRules[idx].arg_3 := A_LoopField
        }        				
    }	
}

InsertTemplateField(targetText, templateText, replacementText, iniItem)
{    
    if (InStr(targetText, templateText))
    {
        if (replacementText = "")
            LogEntry("INFO: A fill value for template item " . templateText . " was unavailable in " . iniItem . "=" . targetText . ". Replaced field with blank.`n")
        resultText := StrReplace(targetText, templateText, replacementText)
    }
    else
        resultText := targetText
    
    return resultText
}

;argList = array of input arguments
;originalArgs = comma delimited list of original arg list
;newArgs = comma delimited list of new arg list
;typeArgs = "A_Args" or "aEmuArgs" (used for validation)
ProcessOverrideArgs(&argList, typeArgs:="A_Args")
{    
    global cl_start_screen, cl_exit_screen, cl_run_apps

    bPreprocessArgs := false
    emu_arg := ""

    cl_start_screen := ""
    cl_exit_screen := ""
    cl_run_apps := ""
 
    newArgList := argList.Clone()
    
    for n, input_arg in argList
    {
        ;Support: -use_args
        ;format:  -use_args=emulator,argument#
        ;purpose: rebuilds the command line using:
        ;   arg_1 = the specified emulator key
        ;   arg_2 = the argument# from the original command line  		
        if (InStr(input_arg, "-use_args"))
        {
            if (typeArgs = "aEmuArgs")
            {
                LogEntry("ERROR: -use_args is not legal in a parameter list.`n")
                ExitApp
            }
            
            input_arg_decomp := StrSplit(input_arg, ["=",","], " ")
            emu_arg := input_arg_decomp[input_arg_decomp.Length()-1]
            rom_arg := A_Args[input_arg_decomp[input_arg_decomp.Length()]]
            LogEntry("INFO: Found: " . input_arg . " on command line. Overriding command line.`n")
            bPreprocessArgs := true
        }
        
        ;Override start_screen settings from the command line
        if (InStr(input_arg, "-start_screen"))
        {
            input_arg_decomp := StrSplit(input_arg, ["="], " ")
            cl_start_screen := input_arg_decomp[2]
            newArgList.Delete(n)
            LogEntry("INFO: Found: " input_arg " on command line. Overriding start_screen setting.`n")
            bPreprocessArgs := true
        }
        
        ;Override exit_screen settings from the command line
        if (InStr(input_arg, "-exit_screen"))
        {
            input_arg_decomp := StrSplit(input_arg, ["="], " ")
            cl_exit_screen := input_arg_decomp[2]
            newArgList.Delete(n)
            LogEntry("INFO: Found: " input_arg " on command line. Overriding exit_screen setting.`n")
            bPreprocessArgs := true
        }
        
        ;Override run_apps settings from the command line
        ;if set to nothing ( cl_run_apps= ) then no apps will run
        if (InStr(input_arg, "-run_apps"))
        {
            input_arg_decomp := StrSplit(input_arg, ["="], " ")
            input_arg_decomp[2] != "" ? cl_run_apps := input_arg_decomp[2] : cl_run_apps := "EMPTY"
            newArgList.Delete(n)
            LogEntry("INFO: Found: " input_arg " on command line. Overriding emulator's run_apps setting.`n")
            bPreprocessArgs := true
        }

        ;fast load prevents meta name caching during startup
        ;Suitable when using with front ends that don't require proper names
        if (InStr(input_arg, "-fast_load"))
        {
            gCfg.fast_load := 1
            newArgList.Delete(n)
        }
    }

    ;rebuild a new arglist without the removed items
    argList := Array()
    for n, input_arg in newArgList
    {
        if (IsSet(input_arg))
            argList.Push(input_arg)
    }

    if (emu_arg)
    {
        argList := Array()
        argList[1] := emu_arg
        argList[2] := rom_arg
    }
    
    return bPreprocessArgs
}

;Takes a searchPath and returns a reversed array of its paths
ParseSearchPath(sysKey)
{
    ;if a root path search is specified (i.e. [root_folder]_*\roms\*.zip) then we create
    ;an array of all the search paths.
    ;we don't see the [root_folder] template here since it will already have been replaced.
    ;so we use the extra "*" and root_folder value to figure things out.
    
    searchPath := oEmulators.Emulators[sysKey].search_path
    if (!searchPath)
        return false
    
    rootFolder := oEmulators.Emulators[sysKey].root_folder
    
    bIsRootSearch := InStr(searchPath, "*",,-2, -2)
    if (bIsRootSearch && !InStr(searchPath, "||"))
    {
        searchPattern := SubStr(searchPath, 1, bIsRootSearch)
        romSegment := StrReplace(searchPath, searchPattern, "")
        aSearchPaths := Array()
        try
        {
            aSearchPaths.Push(rootFolder . romSegment )
            Loop Files searchPattern, "D"
                aSearchPaths.Push(A_LoopFileFullPath . romSegment)
        }
        catch as e
        {
            err := "Failed root folder search. Search pattern [" searchPattern "]"
            throw { what: err, file: A_LineFile, line: A_LineNumber }
        }	
        
        ReverseArray(&aSearchPaths)
    }
    else	
        aSearchPaths := SplitByStringDelimiter(searchPath, "||")

    ;Modify delimiter if needed
    ;This is to support possible commas in path
    for n, sPath in aSearchPaths
    {
        aSearchPaths[n] := TokenizePath(aSearchPaths[n])
    }
    
    return aSearchPaths
}

FrontEndStartup()
{
    global gCfg, log_file
    
    ran_fe := false
    
    ;get list of apps to run after front end exits back to the OS
    ;also get the os asset_name and do some validation
    config_section := "Front_End_OS"
    os_fe_key := IniRead(config_file, config_section, "fe_key", A_Space)
    os_exe_full_path := TokenizePath(IniRead(config_file, config_section, "exe_full_path", A_Space))
    os_asset_name := IniRead(config_file, config_section, "asset_name", A_Space)
    os_run_apps := IniRead(config_file, config_section, "run_apps", A_Space)
    
    if (os_fe_key != "os")
    {	
        LogEntry("ERROR: CONFIGURATION: fe_key in default [Front_End_OS] section must be set to `"os`".`n")
        ExitApp
    }
    
    else if (os_exe_full_path)
    {
        LogEntry("ERROR: CONFIGURATION: [Front_End_OS] section in " cConfigFileName " does not support the exe_full_path key.`n")
        ExitApp
    }
    
    fe_sections := oConfigFile.GetGroupSections("Front_End")
    for i, config_section in fe_sections
    {
        if (config_section == "Front_End_OS") ;we already processed this one above
            continue

        this_fe_key := IniRead(config_file, config_section, "fe_key", A_Space)
        
        ;Check to see if eip.exe was called with a valid front-end as an argument
        ;if so, we'll run in front-end mode.
        if (A_Args[1] == this_fe_key) 
        {			
            ;We have confirmed that arcadeEIP was launched in front-end mode so lets rename
            ;the log file and continue logging in that file so that it won't be overwritten
            ;by any subsequent emulator mode runs.
            try
            {
                fe_log_file := A_ScriptDir "\" cFELogFileName
                if FileExist(fe_log_file)
                    FileDelete(fe_log_file)
                
                if FileExist(log_file)
                    FileMove(log_file, fe_log_file) ;renames log file
                
                log_file := fe_log_file		
            }
            catch as e
            {		
                LogEntry("ERROR: Renaming log file: " FormatErrorMessage(e) "`n")
                ExitApp
            }				
            
            this_asset_name := IniRead(config_file, config_section, "asset_name", A_Space)
            this_run_apps := IniRead(config_file, config_section, "run_apps", A_Space)
            this_exe_full_path := TokenizePath(IniRead(config_file, config_section, "exe_full_path", A_Space))
            
            ;Since this method is called before ProcessIni() is called, 
            ;we need to read the configured applications
            ProcessIniApplications()
            
            gCfg.fe_key := this_fe_key ;needed by RunApps (gCfg.fe_key is a global)
            
            ;No rom is specified, so if an application that might use a rom_name wants to
            ;also be used with a front-end, it is recommended that [smart_name] is used
            ;instead of [rom_name] in the profile template.
            RunApps(this_asset_name, this_asset_name, this_run_apps,"+") ;run one time startup apps
            RunApps(this_asset_name, this_asset_name, this_run_apps) ;run startup/reentry apps
                
            try
            {
                Launch("RunWait", this_exe_full_path, "", "FRONT-END")
                LogEntry("INFO: Exiting Front-end.`n")
            }
            catch as e
            {		
                LogEntry("ERROR: FrontEndStartup: Launching Front-End: " FormatErrorMessage(e) "`n")
                ExitApp
            }
            
            RunApps(this_asset_name, this_asset_name, this_run_apps,"-")
            RunApps(os_asset_name, os_asset_name, os_run_apps)
            
            ran_fe := true
        }
    }
    
    return ran_fe
}

;Replace any commas past the last \ character with the currently
;set gCfg.path_delimiter. This makes it easier for the parser to 
;deal with paths that contain commas.
TokenizePath(sPath)
{
	;Only do this if the path_delimiter is not a comma
	;in order to preserve legacy behavior in that case
	if (gCfg.path_delimiter != ",")
	{
		nLastBs := InStr(sPath, "\",, -1)
		sFirstPart := SubStr(sPath, 1, nLastBs)
		sLastPart := SubStr(sPath, nLastBs+1)
		sLastPart := StrReplace(sLastPart, ",", "|")
	}
	else
	{
		return sPath
	}

	return sFirstPart . sLastPart
}

IdleLogEntry(logString)
{
    FileAppend logString . "`n", idle_log_file
}

IsEmulatorActive()
{    
    ;if (WinExist("ahk_pid " pid_emulator))
    if (WinActive("ahk_pid " pid_emulator))
        return true
    else
        return false
}

;Create a directory and log the activity
CreateDirAndLog(d)
{
    if (!InStr(FileExist(d), "D"))
    {
        try
            DirCreate d
        catch
            LogEntry("NOTICE: Failed to create folder, " d ".`n")
        else        
            LogEntry("INFO: Created folder, " d ".`n")            
    }

    return
}

;Delete a file or folder and log the activity
;@t is "D" (directory) or "F" (file)
;@f is full name and path of the file or folder/directory. 
DeleteAndLog(t, f)
{
    if (t == "F")
    {
        if (FileExist(f)) 
        {
            try {
                FileDelete(f)
            }
            catch as e {
                LogEntry("INFO: File could not be deleted: " f ". Error was: " FormatErrorMessage(e) "`n")
            }
            else {
                LogEntry("INFO: Deleted file: " f ".`n")
            }
        }
    }
    if (t == "D")
    {
        if (FileExist(f)) 
        {
            try {
                DirDelete(f, 1)
            }
            catch as e {
                LogEntry("INFO: Folder could not be deleted: " f ". Error was: " FormatErrorMessage(e) "`n")
            }
            else {
                LogEntry("INFO: Deleted folder: " f ".`n")
            }
        }
    }

    return
}

LogEntry(logString, continueLine:=false)
{
    global log_file

    ;if making changes to this function
    ;also update the function in cf_add_param.ahk
    ;(i.e. the custom function example) 
    
    if (bSuppressLogging)
        return
    
    elapsedTime := A_TickCount - start_tick
    lenElapsedTime := StrLen(elapsedTime)
    
    if (lenElapsedTime > 5)
        formatString := "{1:0" . lenElapsedTime . "}"
    else
        formatString := "{1:05}"

    elapsedTime := Format(formatString, elapsedTime)
    elapsedTime := SubStr(elapsedTime,1,StrLen(elapsedTime)-3) . "." . SubStr(elapsedTime, StrLen(elapsedTime)-2, 3)

    if (gCfg.use_log)
    { 
        if (continueLine)
            FileAppend logString, log_file
        else
            FileAppend "[" . elapsedTime . "] " . logString, log_file
    }

    if (InStr(logString, "ERROR:"))
    {
        DoBeep()
        
        if (!gCfg.debug_mode)
        {
            if (gCfg.use_log && (gCfg.fe_key = "os" || gCfg.fe_key = ""))
                ShowLog()
        }
    }

    return
}

;Log otherwise unhandled errors (spawed by OnError)
LogError(e, mode)
{
    LogEntry("ERROR: Unhandled exception: " FormatErrorMessage(e) "`n")
    ExitApp
}

;Add contents to the directswitch_folder.
;Used during initialization and -clean operations
PopulateDirectSwitchFolder()
{
    if (InStr(FileExist(directswitch_folder), "D") && !FileExist(directswitch_folder "\readme.txt"))
    {
        try 
           FileAppend "
        (
A direct-launch file is simply a text (txt) file whose name is either a hotstring or hotkey sequence, and whose
content is a vector to a game in the form <sys_key> <rom>. When the hot-sequence specified by the file name
is issued on the machine, arcadeEIP will immediately switch to the game specified by the file contents.
Direct-launch files must be placed in the \Direct subfolder of arcadeEIP.

Hotstring Files
===============
To create a hotstring file, the name of the file must begin with the prefix "@!@", and be followed by a 
unique text string.  See example, @!@mame_zaxxon.txt file in this folder which illustrates a file that will
launch Zaxxon in MAME using the key sequence "@!@mame_zaxxon" followed by ENTER.

Note that normally, the terminating ENTER will be issued by the external macro that broadcasts the string (such
as a control panel button macro, Elgato Stream Deck macro, etc.).

Important: Hotstrings will only be recognized by arcadeEIP if it is the active window. A reliable way to ensure
this is to perform a virtual mouse click on the window prior to issuing the hotstring. Therefore, any macro 
created to use hotstrings to switch games should first perform such a mouse click followed by a short delay 
(200ms should be sufficient), prior to sending the hotstring text. If this is not possible, then you must use
a hotkey file instead.

Hotkey Files
============
To create a hotkey file, the name of the file must be a hotkey sequence composed of any Autohotkey modifers
(https://www.autohotkey.com/docs/Hotkeys.htm) that are permitted in a filename.  See example ^!1.txt in this 
folder that will launch the game Galaga in MAME using the key sequence Ctrl-Alt-1 anytime while in arcadeEIP.

In general, hotstrings are preferred when there are a large number of games that will be mapped, since you do
not have to worry about running out of hotkey combinations or potential conflicts with hotkeys of other 
applications.  Hotkeys are preferred when there are fewer games, or it is difficult to automate a mouse click
operation before issuing a hotstring. 

Tip
===
If you would like to create hotstring files in bulk, you may use the -createproxy command line function 
that is documented in "Command Line Reference Guide.pdf". For example, by using a command line such as...

   >eip.exe -createproxy D:\Emulators\MAME\roms\*.zip D:\arcadeEIP\temp\*.txt mame rom_full_path @!@

you can easily create direct-switch proxy files having an appropriate prefix for all mame roms. Once done,
you can then copy just the ones you want into the \Direct folder as needed.

Warning
=======
Note: Other than the two types of files listed above and this readme.txt file, do not place files of any other 
type in this folder or arcadeEIP will fail with an error.

        )", directswitch_folder "\readme.txt"

        catch     
            LogEntry("NOTICE: Failed to create file, " directswitch_folder "\readme.txt.`n")
        else  
            LogEntry("INFO: Created file, " directswitch_folder "\readme.txt.`n")            
    }

    if (InStr(FileExist(directswitch_folder), "D") && !FileExist(directswitch_folder . "\^!1.txt"))
    {
        try
            FileAppend "mame asteroid", directswitch_folder "\^!1.txt"          ;create sample direct-switch hotkey file
        catch
            LogEntry("NOTICE: Failed to create file, " directswitch_folder "\^!1.txt.`n") 
        else       
            LogEntry("INFO: Created file, " directswitch_folder "\^!1.txt.`n")     
    }

    if (InStr(FileExist(directswitch_folder), "D") && !FileExist(directswitch_folder . "\@!@mame_zaxxon.txt"))
    {
        try
            FileAppend "mame zaxxon", directswitch_folder "\@!@mame_zaxxon.txt" ;create sample direct-switch hotstring file
        catch
            LogEntry("NOTICE: Failed to create file, " directswitch_folder "\@!@mame_zaxxon.txt.`n") 
        else     
            LogEntry("INFO: Created file, " directswitch_folder "\@!@mame_zaxxon.txt.`n")            
    }
}