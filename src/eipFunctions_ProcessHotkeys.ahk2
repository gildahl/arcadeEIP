; arcadeEIP (eip.exe) - Arcade Emulator Integration Player
; Â© 2024 David G. Dahlstrom
; File: eipFunctions_ProcessHotkeys.ahk2

;Since arcadeEIP mainly runs on top of emulators, it never takes the focus.
;This permits it to operate independently of the emulators which have the focus.
;Therefore, system level hotkeys are used for all user interaction with arcadeEIP.
;These hotkeys are either enabled or disabled depending on what mode the application
;is in (for example, game selection screen displayed or pause screen displayed)
;Most of this hotkey management is performed using the functions in this file.

;This is the main function for showing and hiding the game select screen (guiSelect)
;option can be "0" (not switching a game) or "1" (switching to a new game)
MagicKey(option, theHotkey:="")
{
    global gCfg, g_mouse_clicks_off, g_guiselect_visible
    static sbRanPickerApps := false

    ;*** HOUSE OF CARDS ALERT ***
    ;BEWARE that the sequence of events in this function are
    ;very delicate.  Test throroughly if changing anything here.
   
    if (magic_key_off || !bEmuWindowActive || g_guiscorecard)
    {
        mk := magic_key_off == true ? "true" : "false"
        ewa := bEmuWindowActive == true ? "true" : "false"
        gsc := g_guiscorecard == true ? "true" : "false"
        LogEntry("DEBUG: Could not display game select menu in MagicKey(). magic_key_off: " mk " bEmuWindowActive: " ewa " g_guiscorecard: " gsc)

        oBASS.Play("error")
        return
    }

    if (!g_guiselect_visible) ;guiSelect hidden, so lets show it.
    {
        ModifyHotkeys("blocking")

        ;Set speed of RunWaitTimer frequency
        ;Determines scroll performance in the select screen.
        SetTimer RunWaitTimer, cRunWaitTimer_Period

        ;if picker screen does not dismiss, check to see if magic_key is mapped to pause_key or exit_key
        ;and then ensure that pause_key or exit_key is mapped the same in the picker cp configuration as in
        ;the game's cp configuration.          
        ;MouseGetPos ,, &pid_screen
        ;OutputDebug "Pid: " pid_screen "`n"

        oMouseDelta.SetState(1) 
        oDetectInactivity.Suspend()
        g_mouse_clicks_off := 1

        ;Wait for picker apps to load
        if (gCfg.picker_apps)
        {
            if (gCfg.whitelist == "" || InStr(gCfg.whitelist, gCfg.sys_key " " gCfg.rom_file))
            {
                Hotkey gCfg.magic_key, "Off"

                ShowHideBanner("Please Wait...")
                RunApps(gCfg.picker_asset, "", gCfg.picker_apps)
                ShowHideBanner()          

                Hotkey gCfg.magic_key, "On"
                sbRanPickerApps := true
            }
        }
    
        guiAlpha.Opt("+AlwaysOnTop")

        ;Make game selection screen semi-transparent
        WinSetTransColor "Black 240", "ahk_id " . guiSelect.Hwnd

        if (g_pause_state)
        {
            oFadeAlphaOverlay.Start(1,200,20,16) ;dim the alpha (pause) overlay
        }
        
        oFadeAlphaWindow.Start(1,150,20,16) ;dim the alpha screen

        oBASS.Play("menu")
        guiSelect.Opt("+AlwaysOnTop")

        g_guiselect_visible := true ;must be above ShowControls
        ShowControls("guiSelect") ;ShowControls should always follow a guiSelect +AlwaysOnTop directive          
    }
    else ;guiSelect is visible, so let's hide it.
    {   
        if (g_pause_state)
            oFadeAlphaOverlay.Start(200,0,20,16) ;undim the alpha (pause) overlay   
 
        oFadeAlphaWindow.Start(150,0,20,16) ;undim the alpha screen
        
        oDetectInactivity.Resume()
        oMouseDelta.SetState(0)

        guiSelect.Opt("-AlwaysOnTop")

        ;return focus to the emulator, but not if we are still paused
        ;(if the process is paused, it will crash; and if we are displaying
        ;a pause screen, we don't want to bury it.)
        if (!oPauseProc.Active && !g_guipause_visible) 
        {
            try ControlFocus(WinGetID("ahk_pid " . pid_emulator))
        }

        g_mouse_clicks_off := 0

        g_guiselect_visible := false
        HideControls("guiSelect") 

        ;Reset RunWaitTimer to default frequecy
        SetTimer RunWaitTimer, runwait_default_freq

        ModifyHotkeys("passthrough")

        ;Wait for apps to reload
        ;option 1 means we're switching to a new game so no point
        ;to reload the current game's profile.
        if (gCfg.picker_apps && option == "0" && sbRanPickerApps) 
        {   
            Hotkey gCfg.magic_key, "Off"
           
            ShowHideBanner("Please Wait...")
            RunApps(gCfg.asset_name, gCfg.rom_name, orig_run_apps)
            ShowHideBanner()
            
            Hotkey gCfg.magic_key, "On"
        }

        sbRanPickerApps := false
    }

    KeyWait gCfg.magic_key ;blocks auto-repeat 
}

;Pause/unpause game
;Also shows or hides the pause screen. This pause screen can hold various
;kinds of custom information and images.
;Possible keyState values are "", (Down), or "Up"
PauseKey(keyState, theHotkey:="")
{
    global g_pause_state, g_guipause_visible, g_mouse_clicks_off, pause_key_off

    static paused := false
    static lastTick := 0
    static lastKeyState := "Up"

    if (pause_key_off)
        return

    ;Enforce a delay between pause keystrokes to avoid "button mashing" side effects.
    ;if last key was "down", then allow "up" with no restriction
    ;if last key was "up", then only allow a "down" to pass next, and only after a delay

    pass := false

    if (lastKeyState == "" && keyState == "Up")
        pass := true
    else if (lastKeyState == "Up")
    {
        ;enforce a minimum 300ms delay between pause keystrokes
        if (keyState == "" && A_TickCount - lastTick > 300) 
            pass := true
    }

    if (!pass)
        return

    lastKeyState := keyState
    lastTick := A_TickCount

    ;*****************************************************

    ;Can't pause if...
    ;1. there isn't an active emulator
    ;2. there is no pause command mapping
    ;3. the game select screen is already active (ok to pause prior to game select activation though)
    if (!bEmuWindowActive || !gCfg.map_pause || g_guiselect_visible)
    {
        return
    }

    ;Split map_pause into 1 or 2 values depending on format
    ;1. {Toggle} x, which sends an x-Down and x-Up
    ;2. {a}|{b}, which sends a then b
    ;3. {x}, which just send an x
    aMapPauseArray := StrSplit(gCfg.map_pause, "|")	
	if (aMapPauseArray.Length > 2 || StrLen(aMapPauseArray[1]) == 0)
	    return

    mMapPause := Map()
    for n, val in aMapPauseArray
    {
        mMapPause[n] := aMapPauseArray[n]
    }
	
    ;the {Toggle} tag is a shortcut so one can write: {Toggle} p
    ;instead of: {p DownR}|{p up}
    if (InStr(mMapPause[1], "{Toggle}")) 
    {
        pause_cmd := Trim(StrReplace(mMapPause[1], "{Toggle}", A_Space))
        mMapPause[1] := "{" . pause_cmd . " DownR}"
        mMapPause[2] := "{" . pause_cmd . " up}"
    }

    ;Pause the emulator using the appropriate method
    if (gCfg.map_pause == "{PauseProc}") ;if this is a synthetic pause
    {
        if (keyState == "")
        {
            if (!paused) ;Synthetic PAUSE
            {
                ;this line interfered is image switching during pause...seems ok without it, but keep eye on.
                ;SetTimer RunWaitTimer, 0 ;prevents pid from being used in RunWaitTimer while paused
                
                oDetectInactivity.Suspend()

                if (!g_guiscorecard)
                {
                    if (!g_guiselect_visible) ;avoid bringing guiAlpha to the top when guiSelect is displayed.
                        guiAlpha.Opt("+AlwaysOnTop") ;we will need it on top if guiSelect is not displayed
                }
             
                MasterSound.Off() ;pausing the process while a sound is active can produce a hum.
                oPauseProc.Suspend()
            }
            else ;Synthetic UNPAUSE
            {
                oDetectInactivity.Resume()
                MasterSound.On()                  

                oPauseProc.Resume()
                Sleep 200 ;needed to prevent ControlFocus from being called before proc has finished resuming which can result in a crash
        
                MouseGetPos &OutputVarX, &OutputVarY, &OutputVarWin, &OutputVarControl, 2
                try ControlFocus OutputVarControl, "ahk_pid " . pid_emulator
                
                ;this line interfered is image switching during pause...seems ok without it, but keep eye on.
                ;SetTimer RunWaitTimer, cRunWaitTimer_Period
            }
            paused := paused ? false : true
        }
        else ;if (keyState == "Up")
            return			
    }	
    else if (gCfg.pause_key && gCfg.map_pause) ;if this is a native/mapped pause
    {
        if (mMapPause.Count == 1) ;use if a single input message is adequate
        {
            if (keyState == "")
            {
                pause_cmd := mMapPause[1]
                SendInput pause_cmd
                paused := paused ? false : true
            }
            else ;if (keyState == "Up")
            {
                return
            }
        }
        else if (mMapPause.Count == 2)  ;(pauseToggle) ;only used if a full keystroke must be emulated (like MAME native pause)
        {
            if (keyState =="Up")
            {
                pause_cmd := mMapPause[2]
                SendInput pause_cmd
 
                paused := paused ? false : true
            }
            else
            {
                pause_cmd := mMapPause[1]
                SendInput pause_cmd

                return
            }
        }
    }

    ;Run any pause apps and display the appropriate pause visuals
    if (paused)
    {
        RunApps(gCfg.asset_name, gCfg.rom_name, gCfg.pause_apps)

        oDetectInactivity.Suspend()
        g_pause_state := true
        g_mouse_clicks_off := 1

        if (!g_guiscorecard) ;don't show pause images if pausing from within the scorecard dialog
        {
            if (!g_guiselect_visible && oPauseControl.HasContent())
            {
                guiAlpha.Opt("+AlwaysOnTop")    
                WinSetTransparent 0, "ahk_id " . gGui.guiAlpha_Overlay.Hwnd ;0 is transparent, 255 is opaque
                oFadeAlphaWindow.Start(100,255,20,16)             
                ShowControls("guiPause") ;shows pause images, if any, and turns hotkeys on
                g_guipause_visible := true

                oPauseControl.ShowNavTriangles()
            }
            else if (gCfg.map_pause == "{PauseProc}") ;only called if there are no pause images to show
            {
                guiAlpha.Opt("+AlwaysOnTop") 
                oFadeAlphaWindow.Start(1,150,20,16) ;just fade the screen
            }
        }
        oBASS.Play("pause")
    }
    else ;unpaused
    {
        RunApps(gCfg.asset_name, gCfg.rom_name, gCfg.pause_apps, "-")

        if (!g_guiscorecard)
        {
            if (!g_guiselect_visible && oPauseControl.HasContent())
            {      
                oPauseControl.HideNavTriangles()
                SoundBeep
                SoundBeep      
                HideControls("guiPause") ;hides pause images, if any, and turns hotkeys off 

                ;Don't fade if we're returning from a "native" (transparent) pause page.
                if (oPauseControl.CurrentPageType == "native")
                    oFadeAlphaWindow.Start(255,0,0,1)
                else
                    oFadeAlphaWindow.Start(255,0,20,16)

                WinSetTransparent 255, "ahk_id " . gGui.guiAlpha_Overlay.Hwnd ;0 is transparent, 255 is opaque 
                g_guipause_visible := false
            }
            else if (gCfg.map_pause == "{PauseProc}")
                oFadeAlphaWindow.Start(150,0,20,16)  
        } 

        oDetectInactivity.Resume()
        g_pause_state := false
        g_mouse_clicks_off := 0

        ;Make sure the emulator gets the focus back
        ;ControlFocus,,ahk_pid %pid_emulator%

        oBASS.Play("unpause")
    }

    return
}

;Implements exit key function (along with its companion function, ExitKeyUp())
;internal == "" if exited by native means (not under classicPlayer control)
;internal == 0 if exited under automated control (i.e. direct-switching or attract mode)
;internal == 1 if exited via a hotkey (using a valid map_exit code)
ExitKey(internal, theHotkey:="")
{
    global g_exit_code

    g_exit_code := internal

    if (exit_key_off)
        return

    if (!bEmuWindowActive)
        return

    ;Exit the game select screen if it is currently visible
    if (g_guiselect_visible)
        MagicKey("0")

    ;Unpause if we are paused. Particularly important if 
    ;we have paused the process (i.e. synthetic pause)
    if (g_pause_state)
    {            
        PauseKey("")
        Sleep 100
        PauseKey("Up")
    }
	
	aMapExit := StrSplit(gCfg.map_exit, "|")
	
	if (aMapExit.Length > 2 || StrLen(aMapExit[1]) == 0)
	    return
	
	exit_cmd := aMapExit[1]
	
	if (InStr(exit_cmd, "{CloseTop}"))
	{
        exit_cmd := DoExitFunction("CloseTop", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{CloseActive}"))
	{
        exit_cmd := DoExitFunction("CloseActive", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{WinClose"))
	{		
        exit_cmd := DoExitFunction("WinClose", exit_cmd)        
	}
	
	if (InStr(exit_cmd, "{EndProc}"))
	{
        exit_cmd := DoExitFunction("EndProc", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{Event"))
	{
        exit_cmd := DoExitFunction("Event", exit_cmd)
        return
	}
	
	if (exit_cmd)
    {
		Send exit_cmd
        LogEntry("INFO: Sent Exit Key Sequence: " . exit_cmd . ".`n")
    }

	return
}

;Implements exit key function (along with its companion function ExitKey())
ExitKeyUp(theHotkey:="")
{	
	if (exit_key_off || !bEmuWindowActive || aMapExit.Length == 1 || !aMapExit.Has(2))
		return		
	
	exit_cmd := aMapExit[2]
	
	if (InStr(exit_cmd, "{CloseTop}"))
	{
        exit_cmd := DoExitFunction("CloseTop", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{CloseActive}"))
	{
        exit_cmd := DoExitFunction("CloseActive", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{WinClose"))
	{	
        exit_cmd := DoExitFunction("WinClose", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{EndProc}"))
	{
        exit_cmd := DoExitFunction("EndProc", exit_cmd)
	}
	
	if (InStr(exit_cmd, "{Event"))
	{
        exit_cmd := DoExitFunction("Event", exit_cmd)
        return
	}
	
	if (exit_cmd)
    {
		Send exit_cmd
        LogEntry("INFO: Sent Exit Key Sequence (Up): " . exit_cmd . ".`n")
    }
	
	return
}

;Support function called by ExitKey() and ExitKeyUp()
DoExitFunction(func, exit_cmd)
{  
    if (func == "CloseTop")
    {
        MouseGetPos ,, &id, &control
        winTitle := WinGetTitle("ahk_id " . id)
        WinClose winTitle

        exit_cmd := Trim(StrReplace(exit_cmd, "{CloseTop}", A_Space))
    } 
    if (func == "CloseActive")
    {
        WinClose "A"

        exit_cmd := Trim(StrReplace(exit_cmd, "{CloseActive}", A_Space))
    }
    if (func == "WinClose")
    {
        Sleep 100
        a := InStr(exit_cmd, "{WinClose")  ;start pos of the {WinClose} tag
        b := InStr(exit_cmd, "}",,a,1)  ;end postion of the {WinClose} tag
        c := InStr(exit_cmd, ",",,a)  ;position of first comma, if any
        if (c != 0)
        {
            d := SubStr(exit_cmd, c+1, b-c-1)    ;the sub to parse for terms
            oWinList := StrSplit(d, ",", " ")

            for n, win in oWinList
            {
                LogEntry("INFO: {WinClose} closing window: " . win . "`n")
                WinClose win
                Sleep 100
            }
        }
        e := SubStr(exit_cmd, a, b-a+1)
        exit_cmd := Trim(StrReplace(gCfg.map_exit, e, A_Space))

        return exit_cmd
    }
    else if (func == "EndProc")
    {

        ;First we will try killing the active window, then we will kill the process.
        ;act_win := WinActive( "A" )
        ;WinClose, ahk_id %act_win%
        LogEntry("INFO: {EndProc} terminating emulator process.`n")
        ProcessClose pid_emulator ;kill the emulator process

        exit_cmd := Trim(StrReplace(exit_cmd, "{EndProc}", A_Space))

        return exit_cmd
    }
    else if (func == "Event")
    {
        ;These default values work well for mame
        skd_delay := -1
        skd_duration := 110

        ;This code permits the {Event} tag to be appended with values to override the default SetKeyDuration
        ;values above, for example, by specifying {Event,-1,-1}. Altirra needs to to avoid beeping
        a := InStr(exit_cmd, "{Event")                      ;start pos of the {Event tag
        b := InStr(exit_cmd, "}",,a,1)                      ;end postion of the {Event tag
        c := SubStr(exit_cmd, a, b-a)                       ;the {Event tag to parse for terms
        oTerms := StrSplit(c,",",A_Space)                   ;number of comma separated terms
        d := SubStr(exit_cmd, a, b-a+1)                     ;Identify the {Event} tag, including any terms 
        exit_cmd := Trim(StrReplace(exit_cmd, d, A_Space))  ;Remove the tag
        e := oTerms.Length                                   ;replace skd_delay and skd_duration with terms if found
        if (e >= 2)
            skd_delay := oTerms[2]
        if (e == 3)
            skd_duration := oTerms[3]
      
        oldKeyDelay := A_KeyDelay
        oldKeyDuration := A_KeyDuration
        SetKeyDelay skd_delay, skd_duration 

        SendEvent exit_cmd  
            LogEntry("INFO: Sent {Event} Exit Key Sequence: " . exit_cmd . ".`n")   

        SetKeyDelay oldKeyDelay, oldKeyDuration ;restore previous values

        return exit_cmd
    }
}

;Hide controls on specified gui windows
HideControls(guiName)
{
    global gGui

    if (guiName == "guiPause")
    {
        Critical
        oPauseControl.GoPage("hide")
        ControlActivationState.DisablePauseControls()
    }

    if (guiName == "guiSelect")
    {
        oSelectListControl.Hide()
        ControlActivationState.DisableSelectControls()
    }

    if (guiName == "guiStart")
    {
        gGui.guiStart_Label.Visible := false
        gGui.guiStart_Rom.Visible := false
        gGui.guiStart_RomDesc.Visible := false
        gGui.guiStart_Logo.Visible := false
        gGui.guiStart_LicenseBanner.Visible := false
    }

    if (guiName == "guiExit")
    {
        gGui.guiExit_Label.Visible := false
        gGui.guiExit_Logo.Visible := false
    }
}

;Show controls on specified gui windows
ShowControls(guiName)
{
    global gGui

    if (guiName == "guiPause")
    {
        Critical
        oPauseControl.GoPage("start")
        ControlActivationState.EnablePauseControls()
    }

    if (guiName == "guiSelect")
    {
        oSelectListControl.Show()
        ControlActivationState.EnableSelectControls()
    }
}

;Creates hotkeys/hotstrings for direct game switching
AddDirectSwitchHotKeys()
{
    global
    local key, hstr, lowerFileName, e

    hklist := Array()

    HotString("EndChars", "`n") ;default is `n (ENTER) and the semi-colon

    Loop Files directswitch_pattern
    {
        lowerFileName := StrLower(A_LoopFileName)
        if (lowerFileName == "readme.txt")
            continue

        try
        {
            if (SubStr(A_LoopFileName,1,3) == gCfg.hotstring_prefix) ;default hotstring_start value is '@!@'
            {
                Loop Read A_LoopFileFullPath
                {
                    vector := A_LoopReadLine 
                    break ;only read the first line
                }
    
                SplitPath A_LoopFileName,,,, &key
                fVector := DirectSwitch.Bind(vector)
                
                hklist.Push(key)
                hstr := ":X:" . key  ;colons bound the hotstring prefix, X indicates a function call

                HotString(hstr, fVector)
            }
            else ;assume its a hotkey spec
            {
                Loop Read A_LoopFileFullPath
                {
                    vector := A_LoopReadLine 
                    break ;only read the first line
                }
        
                SplitPath A_LoopFileName,,,, &key
                fVector := DirectSwitch.Bind(vector)
                hklist.Push(key)
                Hotkey key, fVector
            }
        }
        Catch as e
        {
            LogEntry("ERROR: Trying to process hotkey/hotstring file: " . A_LoopFileFullPath . ". Please ensure this is a correctly formatted hotkey/hotstring file or remove it from the \Direct folder.`n")
            ExitApp
        }
    }

    return hklist
}

;Support scrolling functions in guiSelect and the pause screen.
ScrollList(direction, theHotkey:="")
{
    ;if the high score entry screen is active
    if (g_guiscorecard)
    {
        ;OutputDebug "g_guiscorecard: " g_guiscorecard " direction: " direction "`n"
        Switch direction
        {
            Case "r":  
                Loop Parse gCfg.left_key, "CSV"
                    Hotkey A_LoopField, "Off"

                try ScorecardDialog.HighScoreNavigate(direction)
                
                Loop Parse gCfg.left_key, "CSV"
                    Hotkey A_LoopField, "On"

            Case "l":
                Loop Parse gCfg.right_key, "CSV"
                    Hotkey A_LoopField, "Off"

                try ScorecardDialog.HighScoreNavigate(direction)
                
                Loop Parse gCfg.right_key, "CSV"
                    Hotkey A_LoopField, "On"
            Case "u": 
                try ScorecardDialog.HighScoreNavigate(direction)
            Case "d":
                try ScorecardDialog.HighScoreNavigate(direction)
            Case "s": ;select
                try ScorecardDialog.HighScoreNavigate(direction)
        }

        return
    }

    Switch direction
    {
        ;handle paging in the pause screen
        Case "r":
            if (g_pause_state && !g_guiselect_visible)
            {
                Loop Parse gCfg.left_key, "CSV"
                    Hotkey A_LoopField, "Off"

                PauseScroll(direction)
                oBASS.Play("page")
           
                Loop Parse gCfg.left_key, "CSV"
                    Hotkey A_LoopField, "On"

                return
            }

        Case "l":
            if (g_pause_state && !g_guiselect_visible)
            {
                Loop Parse gCfg.right_key, "CSV"
                    Hotkey A_LoopField, "Off"

                PauseScroll(direction)
                oBASS.Play("page")            
            
                Loop Parse gCfg.right_key, "CSV"
                    Hotkey A_LoopField, "On"

                return
            }
    }

    ;remaining keys only valid in the select screen
    if (!g_guiselect_visible || !g_guiselect_loaded)
        return

    Switch direction
    {
        Case "d","u","home","end","pu","pd","sgu","sgd":  ;navigation
            Critical "On"
            try oSelectListControl.ScrollVertical(direction)
            Critical "Off"
        Case "s": ;launch game (i.e. "select")
            if (g_directswitch_args)
                return
            
            if (oSelectListControl.IsValidVector())
            {
                oBASS.Play("select")
                MagicKey("1") ;the "1" indicates we're switching games
                oSelectListControl.SwitchGame()
            }

        ;it is important for this "control" to turn off the opposing hot key
        ;to prevent re-entry issues stemming from quickly toggling back and forth
        ;between left and right (vertical scroll control does not seem to 
        ; require this)
        Case "r":  
            Loop Parse gCfg.left_key, "CSV"
                Hotkey A_LoopField, "Off"

            try oSelectListControl.ScrollHorizontal(direction)
            
            Loop Parse gCfg.left_key, "CSV"
                Hotkey A_LoopField, "On"

        Case "l":
            Loop Parse gCfg.right_key, "CSV"
                Hotkey A_LoopField, "Off"

            try oSelectListControl.ScrollHorizontal(direction)
            
            Loop Parse gCfg.right_key, "CSV"
                Hotkey A_LoopField, "On"

        Case "picks","tog","targ":  ;picks toggles the picks (formerly favorites) list, "tog" adds/removes single item, "targ" toggles edit mode
            Critical "On"
            try oSelectListControl.SublistCommand(direction)
            Critical "Off"
        Case "all", "genre","year", "publisher","developer","players","favorites","rating":
            try oSelectListControl.SublistCommand(direction)
        Case "mark": ;mark as favorite
            try oSelectListControl.SublistCommand(direction)
        Case "star5", "star4", "star3", "star2", "star1", "star0", "star":
            try oSelectListControl.SublistCommand(direction)
        Case "sort":
            ;DisplayMenuBanner("Sort")
            ;Sleep(5000)
            ;HideMenuBanner()
    }

    return
}

;Support function for ScrollList() above.
PauseScroll(direction, screen:=0)
{
    Switch direction
    {
        Case "r":            
            Sleep 0
            Critical
            oPauseControl.GoPage(direction)
            Sleep 300 ;this sleep setting sets the sensitivity  

        Case "l":            
            Sleep 0
            Critical
            oPauseControl.GoPage(direction)
            Sleep 300 ;this sleep setting sets the sensitivity
    }

    return
}

;Support changing hotkeys to either be blocking or passthrough depending
;on the mode of operation.
;hk_style can be "passthrough" or "blocking"
ModifyHotkeys(hk_style)
{
    try
    {
        ;This style is used when a game is in session to allow most hotkeys
        ;to passthrough to the game
        if (hk_style == "passthrough")
        {
            if (gCfg.left_key) {
                Loop Parse gCfg.left_key, "CSV"
                {
                    Hotkey "~" . A_LoopField, fScrollLeft
                    Hotkey "~" . A_LoopField . " UP", fScrollNowhere
                }
            }

            if (gCfg.right_key) {
                Loop Parse gCfg.right_key, "CSV"
                {
                    Hotkey "~" . A_LoopField, fScrollRight
                    Hotkey "~" . A_LoopField . " UP", fScrollNowhere
                }
            }

            if (gCfg.up_key)
                Loop Parse gCfg.up_key, "CSV"
                    Hotkey "~" . A_LoopField, fScrollUp

            if (gCfg.down_key)
                Loop Parse gCfg.down_key, "CSV"
                    Hotkey "~" . A_LoopField, fScrollDown

            if (gCfg.launch_key)
                Loop Parse gCfg.launch_key, "CSV"
                    Hotkey "~" . A_LoopField, fScrollSelect

            if (gCfg.pgdn_key)
                Loop Parse gCfg.pgdn_key, "CSV"
                    Hotkey "~" . A_LoopField, fPageDown

            if (gCfg.pgup_key)
                Loop Parse gCfg.pgup_key, "CSV"
                    Hotkey "~" . A_LoopField, fPageUp

            if (gCfg.sgdn_key)
                Loop Parse gCfg.sgdn_key, "CSV"
                    Hotkey "~" . A_LoopField, fSortGroupDown

            if (gCfg.sgup_key)
                Loop Parse gCfg.sgup_key, "CSV"
                    Hotkey "~" . A_LoopField, fSortGroupUp

            if (gCfg.home_key)
                Loop Parse gCfg.home_key, "CSV"
                    Hotkey "~" . A_LoopField, fHome

            if (gCfg.end_key)
                Loop Parse gCfg.end_key, "CSV"
                    Hotkey "~" . A_LoopField, fEnd

            if (gCfg.list_view_key)
                Loop Parse gCfg.list_view_key, "CSV"
                    Hotkey "~" . A_LoopField, fPicks

            if (gCfg.edit_mode_key)
                Loop Parse gCfg.edit_mode_key, "CSV"
                    Hotkey "~" . A_LoopField, fTarget

            if (gCfg.all_key)
                Loop Parse gCfg.all_key, "CSV"
                    Hotkey "~" . A_LoopField, fAll

            if (gCfg.genre_key)
                Loop Parse gCfg.genre_key, "CSV"
                    Hotkey "~" . A_LoopField, fGenre

            if (gCfg.year_key)
                Loop Parse gCfg.year_key, "CSV"
                    Hotkey "~" . A_LoopField, fYear

            if (gCfg.publisher_key)
                Loop Parse gCfg.publisher_key, "CSV"
                    Hotkey "~" . A_LoopField, fPublisher

            if (gCfg.developer_key)
                Loop Parse gCfg.developer_key, "CSV"
                    Hotkey "~" . A_LoopField, fDeveloper

            if (gCfg.players_key)
                Loop Parse gCfg.players_key, "CSV"
                    Hotkey "~" . A_LoopField, fPlayers

            if (gCfg.rating_key)
                Loop Parse gCfg.rating_key, "CSV"
                    Hotkey "~" . A_LoopField, fRating

            if (gCfg.favorite_key)
                Loop Parse gCfg.favorite_key, "CSV"
                    Hotkey "~" . A_LoopField, fMark

            if (gCfg.sort_key)
                Loop Parse gCfg.sort_key, "CSV"
                    Hotkey "~" . A_LoopField, fSort

            if (gCfg.star5_key)
                Loop Parse gCfg.star5_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar5

            if (gCfg.star4_key)
                Loop Parse gCfg.star4_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar4

            if (gCfg.star3_key)
                Loop Parse gCfg.star3_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar3

            if (gCfg.star2_key)
                Loop Parse gCfg.star2_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar2

            if (gCfg.star1_key)
                Loop Parse gCfg.star1_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar1

            if (gCfg.star0_key)
                Loop Parse gCfg.star0_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar0

            if (gCfg.star_key)
                Loop Parse gCfg.star_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar

            if (gCfg.star_key)
                Loop Parse gCfg.star_key, "CSV"
                    Hotkey "~" . A_LoopField, fStar

            if (gCfg.favorites_key)
                Loop Parse gCfg.favorites_key, "CSV"
                    Hotkey "~" . A_LoopField, fFavorites

            if (gCfg.add_remove_key)
                Loop Parse gCfg.add_remove_key, "CSV"
                    Hotkey "~" . A_LoopField, fToggle

            if (gCfg.scorecard_key)
                Loop Parse gCfg.scorecard_key, "CSV" 
                    Hotkey "~" . A_LoopField, fHighScore
        }
        ;This style is used when in the picker gui, and blocks the
        ;keys from passing through to the game
        else if (hk_style == "blocking")
        {
            if (gCfg.left_key) {
                Loop Parse gCfg.left_key, "CSV" 
                {
                    Hotkey A_LoopField, fScrollLeft
                    Hotkey A_LoopField . " UP", fScrollNowhere
                }
            }

            if (gCfg.right_key) {
                Loop Parse gCfg.right_key, "CSV" 
                {
                    Hotkey A_LoopField, fScrollRight
                    Hotkey A_LoopField . " UP", fScrollNowhere
                }
            }

            if (gCfg.up_key)
                Loop Parse gCfg.up_key, "CSV"
                    Hotkey A_LoopField, fScrollUp

            if (gCfg.down_key)
                Loop Parse gCfg.down_key, "CSV"
                    Hotkey A_LoopField, fScrollDown
        
            if (gCfg.launch_key)
                Loop Parse gCfg.launch_key, "CSV"
                    Hotkey A_LoopField, fScrollSelect

            if (gCfg.pgdn_key)
                Loop Parse gCfg.pgdn_key, "CSV"
                    Hotkey A_LoopField, fPageDown

            if (gCfg.pgup_key)
                Loop Parse gCfg.pgup_key, "CSV"
                    Hotkey A_LoopField, fPageUp

            if (gCfg.sgdn_key)
                Loop Parse gCfg.sgdn_key, "CSV"
                    Hotkey A_LoopField, fSortGroupDown

            if (gCfg.sgup_key)
                Loop Parse gCfg.sgup_key, "CSV"
                    Hotkey A_LoopField, fSortGroupUp

            if (gCfg.home_key)
                Loop Parse gCfg.home_key, "CSV"
                    Hotkey A_LoopField, fHome

            if (gCfg.end_key)
                Loop Parse gCfg.end_key, "CSV"
                    Hotkey A_LoopField, fEnd

            if (gCfg.list_view_key)
                Loop Parse gCfg.list_view_key, "CSV"
                    Hotkey A_LoopField, fPicks

            if (gCfg.edit_mode_key)
                Loop Parse gCfg.edit_mode_key, "CSV"
                    Hotkey A_LoopField, fTarget

            if (gCfg.all_key)
                Loop Parse gCfg.all_key, "CSV"
                    Hotkey A_LoopField, fAll

            if (gCfg.genre_key)
                Loop Parse gCfg.genre_key, "CSV"
                    Hotkey A_LoopField, fGenre

            if (gCfg.year_key)
                Loop Parse gCfg.year_key, "CSV"
                    Hotkey A_LoopField, fYear

            if (gCfg.publisher_key)
                Loop Parse gCfg.publisher_key, "CSV"
                    Hotkey A_LoopField, fPublisher

            if (gCfg.developer_key)
                Loop Parse gCfg.developer_key, "CSV"
                    Hotkey A_LoopField, fDeveloper

            if (gCfg.players_key)
                Loop Parse gCfg.players_key, "CSV"
                    Hotkey A_LoopField, fPlayers

            if (gCfg.rating_key)
                Loop Parse gCfg.rating_key, "CSV"
                    Hotkey A_LoopField, fRating

            if (gCfg.favorite_key)
                Loop Parse gCfg.favorite_key, "CSV"
                    Hotkey A_LoopField, fMark

            if (gCfg.sort_key)
                Loop Parse gCfg.sort_key, "CSV"
                    Hotkey A_LoopField, fSort

            if (gCfg.star5_key)
                Loop Parse gCfg.star5_key, "CSV"
                    Hotkey A_LoopField, fStar5

            if (gCfg.star4_key)
                Loop Parse gCfg.star4_key, "CSV"
                    Hotkey A_LoopField, fStar4

            if (gCfg.star3_key)
                Loop Parse gCfg.star3_key, "CSV"
                    Hotkey A_LoopField, fStar3

            if (gCfg.star2_key)
                Loop Parse gCfg.star2_key, "CSV"
                    Hotkey A_LoopField, fStar2

            if (gCfg.star1_key)
                Loop Parse gCfg.star1_key, "CSV"
                    Hotkey A_LoopField, fStar1

            if (gCfg.star0_key)
                Loop Parse gCfg.star0_key, "CSV"
                    Hotkey A_LoopField, fStar0

            if (gCfg.star_key)
                Loop Parse gCfg.star_key, "CSV"
                    Hotkey A_LoopField, fStar

            if (gCfg.favorites_key)
                Loop Parse gCfg.favorites_key, "CSV"
                    Hotkey A_LoopField, fFavorites

            if (gCfg.add_remove_key)
                Loop Parse gCfg.add_remove_key, "CSV"
                    Hotkey A_LoopField, fToggle

            if (gCfg.scorecard_key)
                Loop Parse gCfg.scorecard_key, "CSV"
                    Hotkey A_LoopField, fHighScore
        }
    }
    catch as e
    {		
        LogEntry("ERROR: ModifyHotkeys(): " . FormatErrorMessage(e) . "`n")
        ExitApp
    }
}

;Handle discrete toggling of the game select screen
;mode == 0  hides the menu
;mode == 1  shows the menu
;mode == 2  toggles the menu
ShowHideMenu(mode, theHotkey:="")
{
    if ((g_guiselect_visible && mode == "0") || (!g_guiselect_visible && mode == "1") || mode == "2")
        MagicKey("0") ;0 sent to MagicKey means we're not switching a game

    return
}

;Initialize the hotkeys
AddHotkeys()
{
    ;functions need to be global since they are used by ModifyHotKeys() above
    global 

    static last_next_key := "", last_previous_key := ""

    local e
    
    try
    {
        fScrollNowhere := ScrollList.Bind("x") ;x gets thrown away

        fDoNothing := DoNothing

        if (last_next_key) {  ;free the last keys used
            Loop Parse last_next_key, "CSV"
                Hotkey "~" . A_LoopField, fDoNothing, "On"
        }

        if (last_previous_key) {  ;free the last keys used
            Loop Parse last_previous_key, "CSV"
                Hotkey "~" . A_LoopField, fDoNothing, "On"
        }

        ;Only create hotkeys for UI if they are defined 
        ;(since user may not be using the feature)

        if (gCfg.left_key) 
        {
            fScrollLeft := ScrollList.Bind("l")
            Loop Parse gCfg.left_key, "CSV" 
            {
                Hotkey "~" . A_LoopField, fScrollLeft, "On"
                Hotkey "~" . A_LoopField . " UP", fScrollNowhere, "On" ;UP prevents key from getting "stuck"
            }
        }

        if (gCfg.right_key) 
        {
            fScrollRight := ScrollList.Bind("r")
            Loop Parse gCfg.right_key, "CSV" 
            {
                Hotkey "~" . A_LoopField, fScrollRight, "On"
                Hotkey "~" . A_LoopField . " UP", fScrollNowhere, "On" ;UP prevents key from getting "stuck"
            }
        }

        if (gCfg.up_key) {
            fScrollUp := ScrollList.Bind("u")
            Loop Parse gCfg.up_key, "CSV"
                Hotkey "~" . A_LoopField, fScrollUp, "On"
        }

        if (gCfg.down_key) {
            fScrollDown := ScrollList.Bind("d")
            Loop Parse gCfg.down_key, "CSV"
                Hotkey "~" . A_LoopField, fScrollDown, "On"
        }

        if (gCfg.launch_key) {
            fScrollSelect := ScrollList.Bind("s")
            Loop Parse gCfg.launch_key, "CSV"
                Hotkey "~" . A_LoopField, fScrollSelect, "On"
        }

        if (gCfg.pgdn_key) {
            fPageDown := ScrollList.Bind("pd")
            Loop Parse gCfg.pgdn_key, "CSV"
                Hotkey "~" . A_LoopField, fPageDown, "On"
        }

        if (gCfg.pgup_key) {
            fPageUp := ScrollList.Bind("pu")
            Loop Parse gCfg.pgup_key, "CSV" 
                Hotkey "~" . A_LoopField, fPageUp, "On"
        }

        if (gCfg.sgdn_key) {
            fSortGroupDown := ScrollList.Bind("sgd")
            Loop Parse gCfg.sgdn_key, "CSV"
                Hotkey "~" . A_LoopField, fSortGroupDown, "On"
        }

        if (gCfg.sgup_key) {
            fSortGroupUp := ScrollList.Bind("sgu")
            Loop Parse gCfg.sgup_key, "CSV" 
                Hotkey "~" . A_LoopField, fSortGroupUp, "On"
        }

        if (gCfg.home_key) {
            fHome := ScrollList.Bind("home")
            Loop Parse gCfg.home_key, "CSV" 
                Hotkey "~" . A_LoopField, fHome, "On"
        }

        if (gCfg.end_key) {
            fEnd := ScrollList.Bind("end")
            Loop Parse gCfg.end_key, "CSV" 
                Hotkey "~" . A_LoopField, fEnd, "On"
        }

        if (gCfg.list_view_key) {
            fPicks := ScrollList.Bind("picks")
            Loop Parse gCfg.list_view_key, "CSV" 
                Hotkey "~" . A_LoopField, fPicks, "On"
        }

        if (gCfg.edit_mode_key) {
            fTarget := ScrollList.Bind("targ")
            Loop Parse gCfg.edit_mode_key, "CSV" 
                Hotkey "~" . A_LoopField, fTarget, "On"
        }

        if (gCfg.all_key) {
            fAll := ScrollList.Bind("all")
            Loop Parse gCfg.all_key, "CSV" 
                Hotkey "~" . A_LoopField, fAll, "On"
        }

        if (gCfg.genre_key) {
            fGenre := ScrollList.Bind("genre")
            Loop Parse gCfg.genre_key, "CSV" 
                Hotkey "~" . A_LoopField, fGenre, "On"
        }

        if (gCfg.year_key) {
            fYear := ScrollList.Bind("year")
            Loop Parse gCfg.year_key, "CSV" 
                Hotkey "~" . A_LoopField, fYear, "On"
        }

        if (gCfg.publisher_key) {
            fPublisher := ScrollList.Bind("publisher")
            Loop Parse gCfg.publisher_key, "CSV" 
                Hotkey "~" . A_LoopField, fPublisher, "On"
        }

        if (gCfg.developer_key) {
            fDeveloper := ScrollList.Bind("developer")
            Loop Parse gCfg.developer_key, "CSV" 
                Hotkey "~" . A_LoopField, fDeveloper, "On"
        }

        if (gCfg.players_key) {
            fPlayers := ScrollList.Bind("players")
            Loop Parse gCfg.players_key, "CSV" 
                Hotkey "~" . A_LoopField, fPlayers, "On"
        }

        if (gCfg.rating_key) {
            fRating := ScrollList.Bind("rating")
            Loop Parse gCfg.rating_key, "CSV" 
                Hotkey "~" . A_LoopField, fRating, "On"
        }

        if (gCfg.favorite_key) {
            fMark := ScrollList.Bind("mark")
            Loop Parse gCfg.favorite_key, "CSV" 
                Hotkey "~" . A_LoopField, fMark, "On"
        }

        if (gCfg.sort_key) {
            fSort := ScrollList.Bind("sort")
            Loop Parse gCfg.sort_key, "CSV" 
                Hotkey "~" . A_LoopField, fSort, "On"
        }

        if (gCfg.star5_key) {
            fStar5 := ScrollList.Bind("star5")
            Loop Parse gCfg.star5_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar5, "On"
        }

        if (gCfg.star4_key) {
            fStar4 := ScrollList.Bind("star4")
            Loop Parse gCfg.star4_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar4, "On"
        }

        if (gCfg.star3_key) {
            fStar3 := ScrollList.Bind("star3")
            Loop Parse gCfg.star3_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar3, "On"
        }

        if (gCfg.star2_key) {
            fStar2 := ScrollList.Bind("star2")
            Loop Parse gCfg.star2_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar2, "On"
        }

        if (gCfg.star1_key) {
            fStar1 := ScrollList.Bind("star1")
            Loop Parse gCfg.star1_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar1, "On"
        }

        if (gCfg.star0_key) {
            fStar0 := ScrollList.Bind("star0")
            Loop Parse gCfg.star0_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar0, "On"
        }

        if (gCfg.star_key) {
            fStar := ScrollList.Bind("star")
            Loop Parse gCfg.star_key, "CSV" 
                Hotkey "~" . A_LoopField, fStar, "On"
        }

        if (gCfg.favorites_key) {
            fFavorites := ScrollList.Bind("favorites")
            Loop Parse gCfg.favorites_key, "CSV" 
                Hotkey "~" . A_LoopField, fFavorites, "On"
        }

        if (gCfg.add_remove_key) {
            fToggle := ScrollList.Bind("tog")
            Loop Parse gCfg.add_remove_key, "CSV" 
                Hotkey "~" . A_LoopField, fToggle, "On"
        }

        if (gCfg.menu_hide_key) {
            fMenuHide := ShowHideMenu.Bind("0")
            Loop Parse gCfg.menu_hide_key, "CSV" 
                Hotkey "~" . A_LoopField, fMenuHide, "On"
        }

        if (gCfg.menu_show_key) {
            fMenuShow := ShowHideMenu.Bind("1")
            Loop Parse gCfg.menu_show_key, "CSV" 
                Hotkey "~" . A_LoopField, fMenuShow, "On"
        }

        if (gCfg.menu_toggle_key) {
            fMenuToggle := ShowHideMenu.Bind("2")
            Loop Parse gCfg.menu_toggle_key, "CSV" 
                Hotkey "~" . A_LoopField, fMenuToggle, "On"
        }

        if (gCfg.next_key) {
            fNext := AttractNext
            Loop Parse gCfg.next_key, "CSV"
                Hotkey "~" . A_LoopField, fNext, "On"
            last_next_key := gCfg.next_key
        }

        if (gCfg.previous_key) {
            fPrevious := AttractPrevious
            Loop Parse gCfg.previous_key, "CSV"
                Hotkey "~" . A_LoopField, fPrevious, "On"
            last_previous_key := gCfg.previous_key
        }

        if (gCfg.lock_game_key) {
            fLockGame := LockGame
            Loop Parse gCfg.lock_game_key, "CSV" 
                Hotkey "~" . A_LoopField, fLockGame, "On"
        }

        if (gCfg.scorecard_key) {
            fHighScore := ScorecardDialog.Scorecard
            Loop Parse gCfg.scorecard_key, "CSV" 
                Hotkey "~" . A_LoopField, fHighScore, "On"
        }

        if (gCfg.panic_key) {
            fKillApp := KillApp
            Hotkey gCfg.panic_key, fKillApp, "On"
        }    
        
        if (gCfg.exit_key != "" && gCfg.magic_key != gCfg.exit_key)
        {
            fExitKeyUp := ExitKeyUp
            fExitKey := ExitKey.Bind("1")
            HotKey gCfg.exit_key,fExitKey, "On"
            HotKey gCfg.exit_key . " Up", fExitKeyUp, "On"
        }

        if (gCfg.quit_key)
        {
            fQuitKeyUp := ExitKeyUp
            fQuitKey := ExitKey.Bind("1")
            HotKey gCfg.quit_key, fQuitKey, "On"
            HotKey gCfg.quit_key . " Up", fQuitKeyUp, "On"
        }

        ;if pause_lock is turned on the pause key will be handled by PauseKeyStrobe()
        if (gCfg.pause_lock == 0)
        {
            if (gCfg.pause_key != "" && gCfg.magic_key != gCfg.pause_key) 
            { 
                fPauseKeyUp := PauseKey.Bind("Up")
                fPauseKey := PauseKey.Bind("")
                Hotkey gCfg.pause_key, fPauseKey, "On"
                Hotkey gCfg.pause_key . " Up", fPauseKeyUp, "On"
            }
        }

        ;Magic key can operate as a conventional hotkey if magic_delay=0, displaying the picker 
        ;immediately upon pressing it or, if magic_delay is set > 0, it will pass native keystrokes  
        ;to the application unless the button is held for > magic_delay milliseconds, at which
        ;point it will display the picker.  The Magic Key keyboard strobe logic is in the RunWaitTimer.

        ;Mapping the magic_key to the pause_key or exit_key is a special case which requries the 1
        ;magic_delay setting. If used, the normal keypress will be passed through on a short press and
        ;display (or dismissal) of the picker will occur on a long press.  It is critical that both the
        ;game and picker profiles are set the use the same pause_key or exit_key in such cases. Also note
        ;that this is not supported when one of these keys is configured as a contorl panel shift key.
        
        if (gCfg.magic_key) 
        {
            if (gCfg.magic_delay > 0) ;using delayed magic key
                fMagicKey := DoNothing ;hotkey just blocks input
            else
            {
                fMagicKey := MagicKey.Bind("0") ;0 is normal invocation
            }
            Hotkey gCfg.magic_key, fMagicKey, "On"
        }          
    }
    catch as e
    {		
        LogEntry("ERROR: AddHotkeys(): " . FormatErrorMessage(e) . "`n")
        ExitApp
    }

    return
}

DoNothing(theHotkey:="")
{
    dummy := 0
    return
}

ActivateHotKeys()
{
    global

    exit_key_off := false
    pause_key_off := false
    magic_key_off := false

    return
}

InActivateHotKeys()
{
    global

    exit_key_off := true
    pause_key_off := true
    magic_key_off := true

    return
}

;Switch to the next game in the attract list.
AttractNext(theHotkey:="")
{   
    ;If startup initialization is still occurring, we can't switch till its done.
    ;So put up a message.
    if (!g_guiselect_loaded)
    {        
        ShowTimedBanner("Game list still loading. Please wait...")
    }

    if (g_exit_code == 0 || g_exit_code == 1)
        return

    if (bEmuWindowActive)
    {
        LogEntry("INFO: Hotkey: Autoswitch mode go to next game selected.`n")
        oDetectInactivity.ForceAction()
    }

    return
}

;Switch to the previously played game. Unlike AttractNext(), this function uses 
;the main mPlayLog rather than the attract list since this seems more like what one
;would expect to happen when stepping back.
AttractPrevious(theHotkey:="")
{
    static last_cycle := 0

    if (!g_guiselect_loaded)
    {
        ShowTimedBanner("At list beginning. No previous title to switch to.")
        return
    }

    if (g_exit_code == 0 || g_exit_code == 1)
        return

    if (bEmuWindowActive)
    {
        ;can't go back past the first played game
        if (mPlayLog["log"].Length == 1)
        {
            ShowTimedBanner("At list beginning. No previous title to switch to.")
            return
        }

        if (mPlayLog["log"][mPlayLog["log"].Length] == mPlayLog["log"][mPlayLog["log"].Length-1])
            mPlayLog["log"].Pop() ;pop off any duplicate predecessors
        
        if (mPlayLog["log"].Length > 1)
            mPlayLog["log"].Pop() ;pop off the current game
        else
        {
            ShowTimedBanner("At list beginning. No previous title to switch to.")
            return ;we must be back at the beginning
        }
        
        vct := mPlayLog["log"][mPlayLog["log"].Length]

        LogEntry("INFO: Hotkey: Autoswitch mode go to previous game.`n")

        DirectSwitch(vct)

        /*
        ;This is the old code for moving back through attract list.
        ;Should still work, so leaving here in case ever needed.
        play_previous := true
        oDetectInactivity.ForceAction()
        */
    }
    
    return
}

LockGame(theHotKey:="")
{
    global gGui, g_lockedState
    static stateText := ""

    ;exit if attract mode is turned off by default
    if (gCfg.attract_delay == 0)
        return

    ;toggle the game lock state
    g_lockedState := g_lockedState == 0 ? g_lockedState := 1 : g_lockedState := 0

    guiAlpha.Opt("+AlwaysOnTop")
    guiDialog.Opt("+AlwaysOnTop")

    if (g_lockedState)
    {
        oDetectInactivity.Suspend() ;turn off the timer
        stateText := "Game locked"
    }
    else
    {
        oDetectInactivity.Resume() ;turn the timer back on
        stateText := "Game Unlocked"
    }

    ;Display the overlay text
    gGui.guiDialog_Banner.Text := stateText
    gGui.guiDialog_Banner.Visible := true

    WinSetTransparent 0, "ahk_id " . gGui.guiAlpha_Overlay.Hwnd
    oFadeAlphaWindow.Start(1,150,20,16) ;dim the alpha screen

    Sleep(750) ;without this, the voice will speak before the "Locked" label is displayed            

    ;OutputDebug MasterSound.GetVolume()
    oVoice.Speak(stateText, 1, 0)
    ;SoundBeep

    gGui.guiDialog_Banner.Visible := false
    oFadeAlphaWindow.Start(150,0,20,16) ;undim the alpha screen
    Sleep(750)
    guiAlpha.Opt("-AlwaysOnTop")  

    return
}

/**
 * Show a text banner in the middle of the screen.
 * sMessageText is the text to display. Call a second time
 * with a blank sMessageText to hide the banner.
 * 
 * @param {string} sMessageText 
 * @returns {void} 
 */
ShowHideBanner(sMessageText:="")
{
    global gGui

    if (sMessageText != "")
        DisplayBanner(sMessageText)
    else
        HideBanner()

    return
}

/**
 * Dims the screen and displays sMessageText in the center of the screen for 5 seconds
 * 
 * @param sMessageText 
 */
ShowTimedBanner(sMessageText)
{
    global gGui

    ControlActivationState.EnableSimpleDialog() ;turns off hotkeys
    DisplayBanner(sMessageText)
    Sleep(5000)            
    HideBanner()
    ControlActivationState.DisableSimpleDialog() ;turns on hotkeys
}

;Display a banner over currently running game
DisplayBanner(sMessageText:="")
{
    guiAlpha.Opt("+AlwaysOnTop")
    guiDialog.Opt("+AlwaysOnTop")

    ;Display the overlay text
    gGui.guiDialog_Banner.Text := sMessageText
    gGui.guiDialog_Banner.Visible := true

    WinSetTransparent 0, "ahk_id " . gGui.guiAlpha_Overlay.Hwnd
    oFadeAlphaWindow.Start(1,150,20,16) ;dim the alpha screen
}

;Hide benner over currently running game
HideBanner()
{
    gGui.guiDialog_Banner.Visible := false
    oFadeAlphaWindow.Start(150,0,20,16) ;undim the alpha screen
    Sleep(750)
    guiAlpha.Opt("-AlwaysOnTop")
}

;Display a banner over the game select menu screen
DisplayMenuBanner(sMessageText:="")
{
    ControlActivationState.DisableSelectControls
    guiAlpha.Opt("+AlwaysOnTop")
    guiDialog.Opt("+AlwaysOnTop")

    ;Display the overlay text
    gGui.guiDialog_Banner.Text := sMessageText
    gGui.guiDialog_Banner.Visible := true
}

;Hide a banner in the game select menu screen
HideMenuBanner()
{
    gGui.guiDialog_Banner.Visible := false
    guiSelect.Opt("+AlwaysOnTop")
    ShowControls("guiSelect") ;should always follow a guiSelect +AlwaysOnTop directive
    ControlActivationState.EnableSelectControls
}

/**
 * **Not currently used**
 * Display a large watermark
 * 
 * @param {string} sMessageText - String to show, or null to hide.
 */
DisplayHideWatermark(sMessageText:="")
{
    if (sMessageText)
    {
        guiAlpha.Opt("+AlwaysOnTop")
        guiDialog.Opt("+AlwaysOnTop")

        ;Display the overlay text
        gGui.guiDialog_Watermark.Text := sMessageText
        gGui.guiDialog_Watermark.Visible := true
    }
    else
    {
        gGui.guiDialog_Watermark.Visible := false
        guiAlpha.Opt("-AlwaysOnTop")
    }
}