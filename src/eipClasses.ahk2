; arcadeEIP (eip.exe) - Arcade Emulator Integration Player
; Â© 2023 David G. Dahlstrom
; File: eipClass_Classes.ahk2

;This file contains smaller miscellaneous classes.

;This class is to support creation of the default configuration
;files (arcadeEIP.ini and arcadeEIP_Example.ini)
class config_manager_class
{
	_filename := ""
	_option := "All"
	_oContent := Array()
	_lineCount := 0

	__New(filename, option := "normal")
	{
		this._filename := filename
		this._option := option ;can be "normal" or "verbose"
		this._oContent := Array()
		this._lineCount := 0
	}

	Add(text_line)
	{
		this._oContent.Push(text_line)
		return
	}

	Write()
	{
		;global
		;local n

		fCfg := FileOpen(this._filename, "a")
		for n, line in this._oContent
		{
			if (this._option == "normal")
				if (line == "" || SubStr(line, 1, 8) == ";Comment" || n <= 5)	;skip comments and empty lines
					continue				
			
			line := line . "`n"	;terminate with line feed

			if (this._lineCount == 0 and this._option == "normal")
			{
				fCfg.write(";==============================================================================================================`n")
            	fCfg.write(";Configuration file template, " . cConfigFileName . " generated by " . cProductName . ", v." . CodeVersion ".`n")
				fCfg.write(";A fresh copy of this file (" . cConfigFileName . ") may be created by using -createcfg at a command prompt.`n")
            	fCfg.write(";You may also create a verbose instructional version of this file (with comments) by using -createcfgexample`n")
           		fCfg.write(";==============================================================================================================`n")
			}

			if ((SubStr(line, 1, 1) == "[" || SubStr(line, 1, 2) == ";[") && this._option == "normal")	
			{	
				fCfg.write("`n") ;blank line before section headers
				this._lineCount++
			}
			else if (InStr(line, "<force_break>"))
				line := "`n"

			this._lineCount++
			fCfg.write(line)			
		}

		fCfg.close()
		return
	}
}

;This class encapsulates a few functions related to
;reading the configuration file (arcadeEIP.ini)
class config_file_class
{
	__New(config_file)
	{
		global

		this._config_file := config_file
		config_sections := IniRead(config_file)
		this._config_sections := config_sections
		this._section_map := Map()
	}

	GetGroupSections(grp)
	{
		global

		grp := grp . "_"
		config_sections := this._config_sections

		grp_sections := Array()
		Loop Parse config_sections, "`n"
		{
			if (InStr(A_LoopField, grp))
			{
				grp_sections.Push(A_LoopField)
			}
		}
		return grp_sections
	}

	ConfigFile
	{
		get => this._config_file
	}

	;Sets global variables based on the key name for the section
	;Currently only used on the Key_Map section to set the key map variables.
	ReadSection(sec)
	{
		global ;gCfg
		local cfg, settings, oSetting, key, value

		cfg := this._config_file
		settings := IniRead(cfg, sec)

		Loop Parse settings, "`n"
		{
			oSetting := StrSplit(A_LoopField, "=", " ", 2)
			key := oSetting[1] 
			value := oSetting[2]

			gCfg.%key% := value
		}
	}
}

class rom_class
{
	_system := ""
	_fullPath := ""
	_matchType := ""
	
    __New(system, fullPath, matchType)
    {
        this._system := system
		this._fullPath := fullPath
		this._matchType := matchType
    }

	system
	{
		get => this._system
		set => this._system := value
	}
	
	fullPath
	{
		get => this._fullPath
		set => this._fullPath := value
	}

	matchType
	{
		get => this._matchType
		set => this._matchType := value
	}
	
	name
	{
		get {
			fullPath := this._fullPath
		    SplitPath fullPath,,,,&name
			return name
		}
	}
	
	fileName
	{
		get {
			fPath := this._fullPath
			SplitPath fPath, &fName
			return fName
		}
	}
	
	extension
	{
		get {
			fullPath := this._fullPath
			SplitPath fullPath,,,&extension
			return extension
		}
	}
	
	folder
	{
		get {
			fPath := this._fullPath
			SplitPath fPath,,&fFolder
			return ffolder
		}
	}
}

class master_sound_class
{
	Off()
	{
		global

		master_mute := SoundGetMute()
        if (master_mute = "Off")
			SoundSetMute +1
	}

	On()
	{
		global

		master_mute := SoundGetMute()
        if (master_mute = "On")
			SoundSetMute +1
	}
}

;suspend a process. 
;used by pause
class suspend_process_class
{
	_active := false

	SetPid(pid)
	{
		;this.Wait() ;make sure current process is resumed
		this._pid := pid
	}

	Suspend()
	{
		this._active := true
		pid := this._pid
		Suspend(true, pid)
	}

	Resume()
	{
		pid := this._pid
		Suspend(false, pid)
		this._active := false
	}

	Wait()
	{
		Loop
		{
			if (this._active)
				Sleep 100
			else
				break
		}
	}
	
	Active
	{		
		get => this._active
	}

	Pid
	{		
		get => this._pid
	}
}